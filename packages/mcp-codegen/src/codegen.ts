import { readFile, readdir } from 'node:fs/promises';
import path from 'node:path';
import { parse } from 'yaml';
import { schemaToTypeAlias, type JsonSchema } from './schema.js';
import { formatDocComment, toCamelCase, toKebabCase, toPascalCase } from './utils.js';

export interface ToolSpec {
  name: string;
  summary?: string;
  description?: string;
  mode?: 'tool' | 'postgres';
  input?: JsonSchema;
  output?: JsonSchema;
  timeout_ms?: number;
  cache_key?: string;
}

export interface ServerSpec {
  id: string;
  version?: string | number;
  description?: string;
  type?: string;
  tools?: ToolSpec[];
}

export interface LoadedServerSpec {
  sourcePath: string;
  definition: ServerSpec;
}

export interface ModuleFile {
  filePath: string;
  contents: string;
  namedExports?: string[];
  typeExports?: string[];
}

const GENERATED_HEADER = [
  '/* eslint-disable */',
  '// ---------------------------------------------------------------------------',
  '// This file is auto-generated by pnpm mcp:codegen. Do not edit manually.',
  '// ---------------------------------------------------------------------------',
  ''
].join('\n');

const TOOL_IMPORT = `import { callMcpTool } from '@magsag/mcp-client';`;
const POSTGRES_IMPORTS = [`import { createPostgresQuery } from '@magsag/mcp-client';`];

const SERIALIZE_OPTIONS: Parameters<typeof JSON.stringify>[2] = 2;

const serializeSchema = (schema: JsonSchema | undefined): string | undefined => {
  if (!schema) {
    return undefined;
  }
  return JSON.stringify(schema, null, SERIALIZE_OPTIONS);
};

const renderMcpConfigObject = (
  serverId: string,
  tool: ToolSpec,
  includeSchemas: boolean
): string => {
  const entries: string[] = [
    `serverId: ${JSON.stringify(serverId)}`,
    `toolName: ${JSON.stringify(tool.name)}`
  ];
  if (tool.summary) {
    entries.push(`summary: ${JSON.stringify(tool.summary)}`);
  }
  if (tool.description) {
    entries.push(`description: ${JSON.stringify(tool.description)}`);
  }
  if (tool.timeout_ms) {
    entries.push(`timeoutMs: ${tool.timeout_ms}`);
  }
  if (tool.cache_key) {
    entries.push(`cacheKey: ${JSON.stringify(tool.cache_key)}`);
  }
  if (includeSchemas) {
    const inputSchema = serializeSchema(tool.input);
    const outputSchema = serializeSchema(tool.output);
    if (inputSchema) {
      entries.push(`inputSchema: ${inputSchema} as const`);
    }
    if (outputSchema) {
      entries.push(`outputSchema: ${outputSchema} as const`);
    }
  }
  return `{
${entries.map((line) => `  ${line},`).join('\n')}
}`;
};

const renderToolModule = (server: ServerSpec, tool: ToolSpec): ModuleFile => {
  const pascalName = toPascalCase(tool.name);
  const functionName = toCamelCase(tool.name);
  const fileName = `${toKebabCase(tool.name)}.ts`;
  const lines: string[] = [GENERATED_HEADER, TOOL_IMPORT, ''];

  const argsTypeName = `${pascalName}Args`;
  const resultTypeName = `${pascalName}Result`;

  lines.push(schemaToTypeAlias(argsTypeName, tool.input, { description: `${tool.name} arguments` }));
  lines.push('');
  lines.push(
    schemaToTypeAlias(resultTypeName, tool.output, { description: `${tool.name} result` })
  );
  lines.push('');

  const doc = formatDocComment([
    tool.summary ?? `Invoke ${tool.name} on ${server.id}`,
    ...(tool.description ? [tool.description] : [])
  ]);
  if (doc) {
    lines.push(doc);
  }

  const configObject = renderMcpConfigObject(server.id, tool, true);
  lines.push(
    `export const ${functionName} = callMcpTool<${argsTypeName}, ${resultTypeName}>(${configObject});`
  );
  lines.push('');

  return {
    filePath: path.join(server.id, fileName),
    contents: `${lines.join('\n')}`.trimEnd() + '\n',
    namedExports: [functionName],
    typeExports: [argsTypeName, resultTypeName]
  };
};

const renderPostgresModule = (server: ServerSpec, tool: ToolSpec): ModuleFile => {
  const pascalName = toPascalCase(tool.name);
  const functionName = toCamelCase(tool.name);
  const fileName = `${toKebabCase(tool.name)}.ts`;
  const lines: string[] = [GENERATED_HEADER, POSTGRES_IMPORTS.join('\n'), ''];

  const argsTypeName = `${pascalName}Args`;
  const resultTypeName = `${pascalName}Result`;

  lines.push(schemaToTypeAlias(argsTypeName, tool.input, { description: `${tool.name} arguments` }));
  lines.push('');
  lines.push(
    schemaToTypeAlias(resultTypeName, tool.output, { description: `${tool.name} result` })
  );
  lines.push('');

  const doc = formatDocComment([
    tool.summary ?? `Invoke ${tool.name} against ${server.id} Postgres workspace`,
    ...(tool.description ? [tool.description] : [])
  ]);
  if (doc) {
    lines.push(doc);
  }

  const configObject = renderMcpConfigObject(server.id, tool, false);
  lines.push(
    `export const ${functionName} = createPostgresQuery<${argsTypeName}, ${resultTypeName}>(${configObject});`
  );
  lines.push('');

  return {
    filePath: path.join(server.id, fileName),
    contents: `${lines.join('\n')}`.trimEnd() + '\n',
    namedExports: [functionName],
    typeExports: [argsTypeName, resultTypeName]
  };
};

const renderServerIndex = (server: ServerSpec, modules: ModuleFile[]): ModuleFile => {
  const lines: string[] = [GENERATED_HEADER];
  for (const moduleFile of modules) {
    const baseName = path.basename(moduleFile.filePath, '.ts');
    const exportName = path.basename(baseName);
    if (moduleFile.namedExports?.length) {
      lines.push(`export { ${moduleFile.namedExports.join(', ')} } from './${exportName}.js';`);
    } else {
      lines.push(`export * from './${exportName}.js';`);
    }
    if (moduleFile.typeExports?.length) {
      lines.push(`export type { ${moduleFile.typeExports.join(', ')} } from './${exportName}.js';`);
    }
  }
  lines.push('');
  return {
    filePath: path.join(server.id, 'index.ts'),
    contents: lines.join('\n') + '\n'
  };
};

const renderRootIndex = (servers: ServerSpec[]): ModuleFile => {
  const lines: string[] = [GENERATED_HEADER];
  for (const server of servers) {
    lines.push(`export * as ${toCamelCase(server.id)} from './${server.id}/index.js';`);
  }
  lines.push('');
  return {
    filePath: 'index.ts',
    contents: lines.join('\n') + '\n'
  };
};

const loadServerSpec = async (filePath: string): Promise<LoadedServerSpec> => {
  const raw = await readFile(filePath, 'utf8');
  const parsed = parse(raw) as ServerSpec;
  return { sourcePath: filePath, definition: parsed };
};

export const loadServerSpecs = async (dir: string): Promise<LoadedServerSpec[]> => {
  const entries = await readdir(dir);
  const specs: LoadedServerSpec[] = [];
  for (const entry of entries) {
    if (!entry.endsWith('.yaml') && !entry.endsWith('.yml')) {
      continue;
    }
    const fullPath = path.join(dir, entry);
    specs.push(await loadServerSpec(fullPath));
  }
  return specs.sort((a, b) => a.definition.id.localeCompare(b.definition.id));
};

export interface GenerateModulesOptions {
  specs: LoadedServerSpec[];
}

export const generateModules = ({ specs }: GenerateModulesOptions): ModuleFile[] => {
  const files: ModuleFile[] = [];
  const servers: ServerSpec[] = [];

  for (const spec of specs) {
    const server = spec.definition;
    if (!server?.id) {
      continue;
    }
    servers.push(server);
    const modules: ModuleFile[] = [];
    for (const tool of server.tools ?? []) {
      const mode = tool.mode ?? (server.type === 'postgres' ? 'postgres' : 'tool');
      const moduleFile =
        mode === 'postgres' ? renderPostgresModule(server, tool) : renderToolModule(server, tool);
      modules.push(moduleFile);
      files.push(moduleFile);
    }
    if (modules.length > 0) {
      files.push(renderServerIndex(server, modules));
    }
  }

  if (servers.length > 0) {
    files.push(renderRootIndex(servers));
  }

  return files;
};
